<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Tap Craft - Mobile Controls + Placeable Wood</title>
<style>
  body, html {
    margin: 0; padding: 0; height: 100%;
    background: linear-gradient(to bottom, #87ceeb 0%, #a0d8f7 100%);
    font-family: monospace;
    user-select: none;
    overflow: hidden;
    touch-action: manipulation;
  }
  #game {
    position: relative;
    width: 600px;
    height: 400px;
    margin: 10px auto;
    background: #4a7c1f; /* grass */
    border: 3px solid #333;
    overflow: hidden;
    touch-action: none;
  }
  .tile {
    position: absolute;
    width: 40px;
    height: 40px;
    box-sizing: border-box;
    text-align: center;
    font-size: 28px;
    line-height: 40px;
    cursor: pointer;
    user-select: none;
  }
  #ui {
    width: 600px;
    margin: 10px auto 0;
    color: #222;
  }
  #healthbar {
    width: 200px;
    height: 20px;
    background: #aaa;
    border-radius: 5px;
    overflow: hidden;
    margin-bottom: 6px;
  }
  #healthbar-inner {
    height: 100%;
    background: #f44;
    width: 100%;
    transition: width 0.3s ease;
  }
  #inventory {
    margin-bottom: 6px;
  }
  #inventory span {
    display: inline-block;
    min-width: 40px;
    border: 1px solid #666;
    margin-right: 4px;
    padding: 2px 6px;
    border-radius: 4px;
    background: #ddd;
    font-weight: bold;
  }
  button {
    padding: 6px 10px;
    font-size: 16px;
    cursor: pointer;
    margin-right: 6px;
    user-select: none;
  }
  #craftPopup, #placeSelector {
    position: fixed;
    top: 50%;
    left: 50%;
    width: 280px;
    background: white;
    border: 2px solid #555;
    border-radius: 8px;
    padding: 10px;
    transform: translate(-50%, -50%);
    box-shadow: 0 0 12px #333;
    display: none;
    z-index: 100;
  }
  #craftPopup h3, #placeSelector h3 {
    margin-top: 0;
    text-align: center;
  }
  #craftPopup button, #placeSelector button {
    width: 100%;
    margin: 6px 0;
  }
  #overlay {
    position: fixed;
    top:0; left:0; right:0; bottom:0;
    background: rgba(0,0,0,0.4);
    display: none;
    z-index: 90;
  }
  #message {
    text-align: center;
    font-weight: bold;
    margin-top: 6px;
    min-height: 20px;
  }
  #timeOfDay {
    font-weight: bold;
    margin-bottom: 8px;
  }
  #monsterCount {
    margin-top: 6px;
    font-weight: bold;
  }
  /* Night overlay */
  #nightOverlay {
    position: absolute;
    pointer-events: none;
    top:0; left:0; right:0; bottom:0;
    background: rgba(0,0,0,0.7);
    transition: background 1s ease;
    z-index: 50;
  }
  /* Mobile controls */
  #mobileControls {
    width: 600px;
    margin: 10px auto 20px;
    display: flex;
    justify-content: center;
    gap: 20px;
    user-select: none;
  }
  .dpad {
    width: 150px;
    height: 150px;
    background: #ddd;
    border-radius: 50%;
    position: relative;
    touch-action: none;
  }
  .dpad button {
    position: absolute;
    width: 40px;
    height: 40px;
    background: #666;
    border: none;
    border-radius: 6px;
    color: white;
    font-weight: bold;
    font-size: 18px;
    line-height: 40px;
    text-align: center;
    user-select: none;
  }
  .dpad button:active {
    background: #444;
  }
  #upBtn { top: 10px; left: 55px; }
  #downBtn { bottom: 10px; left: 55px; }
  #leftBtn { left: 10px; top: 55px; }
  #rightBtn { right: 10px; top: 55px; }
</style>
</head>
<body>

<div id="game"></div>

<div id="ui">
  <div id="healthbar">
    <div id="healthbar-inner"></div>
  </div>
  <div>Health: <span id="healthText">20</span>/20</div>
  <div id="inventory">
    Wood: <span id="woodCount">0</span> |
    Felt: <span id="feltCount">0</span> |
    Doors: <span id="doorCount">0</span> |
    Torches: <span id="torchCount">0</span> |
    Axes: <span id="axeCount">0</span> |
    Chests: <span id="chestCount">0</span> |
    Beds: <span id="bedCount">0</span>
  </div>
  <button id="craftBtn">Open Crafting</button>
  <button id="placeBtn">Select Item to Place</button>
  <div id="message"></div>
  <div id="timeOfDay">Daytime</div>
  <div id="monsterCount"></div>
</div>

<!-- Mobile Controls -->
<div id="mobileControls">
  <div class="dpad">
    <button id="upBtn">‚Üë</button>
    <button id="downBtn">‚Üì</button>
    <button id="leftBtn">‚Üê</button>
    <button id="rightBtn">‚Üí</button>
  </div>
</div>

<div id="overlay"></div>

<div id="craftPopup">
  <h3>Crafting Recipes</h3>
  <button data-item="door">2 Wood = Door</button>
  <button data-item="torch">1 Wood = Torch</button>
  <button data-item="axe">4 Wood = Axe</button>
  <button data-item="chest">3 Wood = Chest</button>
  <button data-item="bed">3 Wood + 2 Felt = Bed</button>
  <button id="closeCraft">Close</button>
</div>

<div id="placeSelector">
  <h3>Select Item to Place</h3>
  <button data-place="wood">Wood Block</button>
  <button data-place="door">Door</button>
  <button data-place="torch">Torch</button>
  <button data-place="axe">Axe</button>
  <button data-place="chest">Chest</button>
  <button data-place="bed">Bed</button>
  <button id="closePlaceSelector">Cancel</button>
</div>

<div id="nightOverlay" style="display:none;"></div>

<script>
// Constants and setup (same as before, added wood block placeable)

const TILE_SIZE = 40;
const WORLD_WIDTH = 15;
const WORLD_HEIGHT = 10;

const tileIcons = {
  grass: '',
  tree: 'üå≥',
  wood: 'ü™µ', // added wood block icon
  door: 'üö™',
  torch: 'üî•',
  chest: 'üì¶',
  bed: 'üõèÔ∏è',
  monster: 'üëπ',
  player: 'üòÄ'
};

const maxTreeHits = 3;
const maxDoorHits = 3;
const maxTorchHits = 1;
const maxChestHits = 3;
const maxBedHits = 3;
const maxWoodHits = 3;

const MONSTER_DAMAGE = 2;
const PLAYER_FIST_DAMAGE = 2;
const PLAYER_AXE_DAMAGE = 5;
const MONSTER_HEALTH = 10;
const PLAYER_MAX_HEALTH = 20;

let world = [];
let player = {
  x: Math.floor(WORLD_WIDTH/2),
  y: Math.floor(WORLD_HEIGHT/2),
  health: PLAYER_MAX_HEALTH,
  maxHealth: PLAYER_MAX_HEALTH,
  inventory: {
    wood: 0,
    felt: 0,
    door: 0,
    torch: 0,
    axe: 0,
    chest: 0,
    bed: 0
  }
};

let isNight = false;
let dayDuration = 300000;
let nightDuration = 300000;
let dayNightTimer = 0;
let lastTimestamp = null;

let monsterDamageInterval = null;
let messageTimeout = null;

let placingMode = false;
let placeItem = null;

const gameEl = document.getElementById('game');
const healthBarInner = document.getElementById('healthbar-inner');
const healthText = document.getElementById('healthText');
const woodCount = document.getElementById('woodCount');
const feltCount = document.getElementById('feltCount');
const doorCount = document.getElementById('doorCount');
const torchCount = document.getElementById('torchCount');
const axeCount = document.getElementById('axeCount');
const chestCount = document.getElementById('chestCount');
const bedCount = document.getElementById('bedCount');
const messageEl = document.getElementById('message');
const timeOfDayEl = document.getElementById('timeOfDay');
const monsterCountEl = document.getElementById('monsterCount');

const craftBtn = document.getElementById('craftBtn');
const placeBtn = document.getElementById('placeBtn');
const craftPopup = document.getElementById('craftPopup');
const overlay = document.getElementById('overlay');
const closeCraftBtn = document.getElementById('closeCraft');
const nightOverlay = document.getElementById('nightOverlay');

const placeSelector = document.getElementById('placeSelector');
const closePlaceSelectorBtn = document.getElementById('closePlaceSelector');

const upBtn = document.getElementById('upBtn');
const downBtn = document.getElementById('downBtn');
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');

// Initialize world
function initWorld() {
  world = [];
  for(let y=0; y<WORLD_HEIGHT; y++) {
    const row = [];
    for(let x=0; x<WORLD_WIDTH; x++) {
      if ((x !== player.x || y !== player.y) && Math.random() < 0.15) {
        row.push({type:'tree', hits:maxTreeHits});
      } else {
        row.push({type:'grass'});
      }
    }
    world.push(row);
  }
  world[player.y][player.x] = {type:'player'};
}

function renderWorld() {
  gameEl.innerHTML = '';
  for(let y=0; y<WORLD_HEIGHT; y++) {
    for(let x=0; x<WORLD_WIDTH; x++) {
      const tile = world[y][x];
      const tileEl = document.createElement('div');
      tileEl.classList.add('tile');
      tileEl.style.left = `${x*TILE_SIZE}px`;
      tileEl.style.top = `${y*TILE_SIZE}px`;
      tileEl.dataset.x = x;
      tileEl.dataset.y = y;
      tileEl.style.color = 'black';

      switch(tile.type) {
        case 'player':
          tileEl.textContent = tileIcons.player;
          tileEl.style.color = 'blue';
          tileEl.style.zIndex = 10;
          tileEl.style.cursor = 'default';
          break;
        case 'monster':
          tileEl.textContent = tileIcons.monster;
          tileEl.style.color = 'darkred';
          tileEl.style.fontWeight = 'bold';
          break;
        case 'tree':
          tileEl.textContent = tileIcons.tree;
          break;
        case 'wood':
          tileEl.textContent = tileIcons.wood;
          break;
        case 'door':
          tileEl.textContent = tileIcons.door;
          break;
        case 'torch':
          tileEl.textContent = tileIcons.torch;
          break;
        case 'chest':
          tileEl.textContent = tileIcons.chest;
          break;
        case 'bed':
          tileEl.textContent = tileIcons.bed;
          break;
        default:
          tileEl.textContent = tileIcons.grass;
          break;
      }

      // Monster health bar
      if(tile.type === 'monster' && tile.health !== undefined) {
        const healthBar = document.createElement('div');
        healthBar.style.position = 'absolute';
        healthBar.style.bottom = '0px';
        healthBar.style.left = '2px';
        healthBar.style.width = '36px';
        healthBar.style.height = '4px';
        healthBar.style.backgroundColor = '#555';
        healthBar.style.borderRadius = '2px';

        const healthFill = document.createElement('div');
        healthFill.style.width = `${(tile.health / MONSTER_HEALTH) * 100}%`;
        healthFill.style.height = '100%';
        healthFill.style.backgroundColor = '#f00';
        healthFill.style.borderRadius = '2px';

        healthBar.appendChild(healthFill);
        tileEl.appendChild(healthBar);
      }

      gameEl.appendChild(tileEl);
    }
  }
}

function updateUI() {
  healthText.textContent = player.health;
  healthBarInner.style.width = `${(player.health/player.maxHealth)*100}%`;
  woodCount.textContent = player.inventory.wood;
  feltCount.textContent = player.inventory.felt;
  doorCount.textContent = player.inventory.door;
  torchCount.textContent = player.inventory.torch;
  axeCount.textContent = player.inventory.axe;
  chestCount.textContent = player.inventory.chest;
  bedCount.textContent = player.inventory.bed;
  timeOfDayEl.textContent = isNight ? 'Nighttime' : 'Daytime';

  let count = 0;
  for(let y=0; y<WORLD_HEIGHT; y++) {
    for(let x=0; x<WORLD_WIDTH; x++) {
      if(world[y][x].type === 'monster') count++;
    }
  }
  monsterCountEl.textContent = `Monsters: ${count}`;
}

function showMessage(text) {
  clearTimeout(messageTimeout);
  messageEl.textContent = text;
  messageTimeout = setTimeout(() => {
    messageEl.textContent = '';
  }, 3500);
}

// Damage tile with axe or fists (trees breakable by fists)
function damageTile(x, y, amount) {
  if(x < 0 || y < 0 || x >= WORLD_WIDTH || y >= WORLD_HEIGHT) return;
  const tile = world[y][x];
  if(!tile) return;

  // Only axe breaks stuff except trees
  if(tile.type !== 'tree' && !playerHasAxe()) {
    showMessage('You need an axe to break this!');
    return;
  }

  if(tile.type === 'tree') {
    tile.hits -= amount;
    if(tile.hits <= 0) {
      world[y][x] = {type:'grass'};
      player.inventory.wood++;
      showMessage('You got 1 wood!');
    }
  } else if(tile.type === 'wood') {
    tile.hits -= amount;
    if(tile.hits <= 0) {
      world[y][x] = {type:'grass'};
      player.inventory.wood++;
      showMessage('Wood block broken!');
    }
  } else if(tile.type === 'door') {
    tile.hits -= amount;
    if(tile.hits <= 0) {
      world[y][x] = {type:'grass'};
      showMessage('Door broken!');
    }
  } else if(tile.type === 'torch') {
    tile.hits -= amount;
    if(tile.hits <= 0) {
      world[y][x] = {type:'grass'};
      showMessage('Torch destroyed!');
    }
  } else if(tile.type === 'chest') {
    tile.hits -= amount;
    if(tile.hits <= 0) {
      world[y][x] = {type:'grass'};
      showMessage('Chest broken!');
    }
  } else if(tile.type === 'bed') {
    tile.hits -= amount;
    if(tile.hits <= 0) {
      world[y][x] = {type:'grass'};
      showMessage('Bed destroyed!');
    }
  } else if(tile.type === 'monster') {
    tile.health -= amount;
    if(tile.health <= 0) {
      world[y][x] = {type:'grass'};
      player.inventory.felt++;
      showMessage('Monster defeated! You got 1 felt.');
    }
  }
}

function playerHasAxe() {
  return player.inventory.axe > 0;
}

function startMonsterDamage() {
  if(monsterDamageInterval) clearInterval(monsterDamageInterval);
  monsterDamageInterval = setInterval(() => {
    let damageTaken = 0;
    for(let y=0; y<WORLD_HEIGHT; y++) {
      for(let x=0; x<WORLD_WIDTH; x++) {
        if(world[y][x].type === 'monster') {
          if(Math.abs(player.x - x) <= 1 && Math.abs(player.y - y) <= 1) {
            player.health -= MONSTER_DAMAGE;
            damageTaken += MONSTER_DAMAGE;
            if(player.health < 0) player.health = 0;
          }
        }
      }
    }
    if(damageTaken > 0) {
      showMessage(`Monster attacked you! -${damageTaken} HP`);
      if(player.health <= 0) {
        showMessage('You died! Restarting game...');
        setTimeout(resetGame, 2000);
      }
      updateUI();
    }
  }, 3000);
}

function spawnMonsters() {
  // Spawn monsters at random positions, not near torches (5 tile radius)
  let count = 0;
  for(let i=0; i<5; i++) {
    let tries = 0;
    while(tries < 50) {
      let x = Math.floor(Math.random()*WORLD_WIDTH);
      let y = Math.floor(Math.random()*WORLD_HEIGHT);
      if(world[y][x].type === 'grass') {
        if(!nearTorch(x,y)) {
          world[y][x] = {type:'monster', health: MONSTER_HEALTH};
          count++;
          break;
        }
      }
      tries++;
    }
  }
  showMessage(`Spawned ${count} monsters`);
}

function clearMonsters() {
  for(let y=0; y<WORLD_HEIGHT; y++) {
    for(let x=0; x<WORLD_WIDTH; x++) {
      if(world[y][x].type === 'monster') {
        world[y][x] = {type:'grass'};
      }
    }
  }
}

function nearTorch(x, y) {
  for(let dy=-5; dy<=5; dy++) {
    for(let dx=-5; dx<=5; dx++) {
      const nx = x + dx;
      const ny = y + dy;
      if(nx >= 0 && ny >= 0 && nx < WORLD_WIDTH && ny < WORLD_HEIGHT) {
        if(world[ny][nx].type === 'torch') return true;
      }
    }
  }
  return false;
}

function sleepInBed() {
  if(isNight) {
    isNight = false;
    dayNightTimer = 0;
    clearMonsters();
    showMessage('You slept and skipped the night!');
    updateTimeOfDayUI();
    updateUI();
    renderWorld();
  }
}

// Handle tile tap
function onTileTap(x,y) {
  if(x === player.x && y === player.y) return;

  const tile = world[y][x];
  if(!tile) return;

  if(placingMode) {
    if(tile.type !== 'grass') {
      showMessage('Can only place on grass!');
      return;
    }
    // Place selected item
    if(player.inventory[placeItem] > 0) {
      world[y][x] = {type: placeItem};
      // Set hits for placed items
      if(placeItem === 'door') world[y][x].hits = maxDoorHits;
      else if(placeItem === 'torch') world[y][x].hits = maxTorchHits;
      else if(placeItem === 'chest') world[y][x].hits = maxChestHits;
      else if(placeItem === 'bed') world[y][x].hits = maxBedHits;
      else if(placeItem === 'wood') world[y][x].hits = maxWoodHits;

      player.inventory[placeItem]--;
      showMessage(`${capitalize(placeItem)} placed!`);
      placingMode = false;
      placeItem = null;
      placeBtn.textContent = "Select Item to Place";
      updateUI();
      renderWorld();
    } else {
      showMessage(`No ${placeItem} left!`);
    }
    return;
  }

  // Break or interact
  if(tile.type === 'tree') {
    damageTile(x,y,1);
  } else if(['door','torch','chest','bed','wood'].includes(tile.type)) {
    if(playerHasAxe()) {
      damageTile(x,y,PLAYER_AXE_DAMAGE);
    } else {
      showMessage('You need an axe to break this!');
    }
  } else if(tile.type === 'monster') {
    if(playerHasAxe()) {
      damageTile(x,y,PLAYER_AXE_DAMAGE);
    } else {
      damageTile(x,y,PLAYER_FIST_DAMAGE);
    }
  } else if(tile.type === 'bed' && isNight) {
    sleepInBed();
  }

  renderWorld();
  updateUI();
}

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// Crafting logic
function canCraft(item) {
  const inv = player.inventory;
  if(item === 'door') return inv.wood >= 2;
  if(item === 'torch') return inv.wood >= 1;
  if(item === 'axe') return inv.wood >= 4;
  if(item === 'chest') return inv.wood >= 3;
  if(item === 'bed') return inv.wood >= 3 && inv.felt >= 2;
  return false;
}

function craftItem(item) {
  if(!canCraft(item)) {
    showMessage('Not enough materials!');
    return;
  }
  if(item === 'door') {
    player.inventory.wood -= 2;
    player.inventory.door++;
  } else if(item === 'torch') {
    player.inventory.wood -= 1;
    player.inventory.torch++;
  } else if(item === 'axe') {
    player.inventory.wood -= 4;
    player.inventory.axe++;
  } else if(item === 'chest') {
    player.inventory.wood -= 3;
    player.inventory.chest++;
  } else if(item === 'bed') {
    player.inventory.wood -= 3;
    player.inventory.felt -= 2;
    player.inventory.bed++;
  }
  showMessage(`Crafted ${capitalize(item)}!`);
  updateUI();
}

// Craft popup buttons
craftPopup.querySelectorAll('button[data-item]').forEach(btn => {
  btn.addEventListener('click', () => {
    craftItem(btn.dataset.item);
  });
});
closeCraftBtn.addEventListener('click', () => {
  craftPopup.style.display = 'none';
  overlay.style.display = 'none';
});
craftBtn.addEventListener('click', () => {
  craftPopup.style.display = 'block';
  overlay.style.display = 'block';
});

// Place selector buttons
placeSelector.querySelectorAll('button[data-place]').forEach(btn => {
  btn.addEventListener('click', () => {
    placeItem = btn.dataset.place;
    if(player.inventory[placeItem] > 0) {
      placingMode = true;
      placeBtn.textContent = `Placing: ${capitalize(placeItem)}`;
      showMessage(`Tap a grass tile to place a ${capitalize(placeItem)}`);
      placeSelector.style.display = 'none';
      overlay.style.display = 'none';
    } else {
      showMessage(`No ${placeItem} available to place!`);
    }
  });
});
closePlaceSelectorBtn.addEventListener('click', () => {
  placingMode = false;
  placeItem = null;
  placeBtn.textContent = "Select Item to Place";
  placeSelector.style.display = 'none';
  overlay.style.display = 'none';
});

placeBtn.addEventListener('click', () => {
  if(placingMode) {
    placingMode = false;
    placeItem = null;
    placeBtn.textContent = "Select Item to Place";
    showMessage('Place mode cancelled');
  } else {
    placeSelector.style.display = 'block';
    overlay.style.display = 'block';
  }
});

overlay.addEventListener('click', () => {
  craftPopup.style.display = 'none';
  placeSelector.style.display = 'none';
  overlay.style.display = 'none';
  placingMode = false;
  placeItem = null;
  placeBtn.textContent = "Select Item to Place";
});

// Player movement with keyboard
function tryMovePlayer(dx, dy) {
  let newX = player.x + dx;
  let newY = player.y + dy;
  if(newX < 0 || newX >= WORLD_WIDTH || newY < 0 || newY >= WORLD_HEIGHT) return;
  const destTile = world[newY][newX];
  if(['grass','torch','door','bed','chest','wood'].includes(destTile.type)) {
    // Move player
    world[player.y][player.x] = {type:'grass'};
    player.x = newX;
    player.y = newY;
    world[player.y][player.x] = {type:'player'};
    renderWorld();
    updateUI();
  }
}

window.addEventListener('keydown', (e) => {
  if(placingMode) return; // no movement while placing
  if(e.repeat) return;
  switch(e.key.toLowerCase()) {
    case 'w':
    case 'arrowup': tryMovePlayer(0,-1); break;
    case 's':
    case 'arrowdown': tryMovePlayer(0,1); break;
    case 'a':
    case 'arrowleft': tryMovePlayer(-1,0); break;
    case 'd':
    case 'arrowright': tryMovePlayer(1,0); break;
  }
});

// Mobile controls
upBtn.addEventListener('touchstart', (e) => { e.preventDefault(); tryMovePlayer(0,-1); });
downBtn.addEventListener('touchstart', (e) => { e.preventDefault(); tryMovePlayer(0,1); });
leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); tryMovePlayer(-1,0); });
rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); tryMovePlayer(1,0); });

// Click/tap on tile to interact or place
gameEl.addEventListener('click', (e) => {
  if(e.target.classList.contains('tile')) {
    const x = parseInt(e.target.dataset.x);
    const y = parseInt(e.target.dataset.y);
    onTileTap(x,y);
  }
});

// Day/Night cycle
function updateDayNight(delta) {
  dayNightTimer += delta;
  if(isNight) {
    if(dayNightTimer >= nightDuration) {
      isNight = false;
      dayNightTimer = 0;
      clearMonsters();
      updateTimeOfDayUI();
      showMessage('Daytime begins!');
      renderWorld();
      updateUI();
    }
  } else {
    if(dayNightTimer >= dayDuration) {
      isNight = true;
      dayNightTimer = 0;
      spawnMonsters();
      updateTimeOfDayUI();
      showMessage('Nighttime begins! Watch out for monsters!');
      renderWorld();
      updateUI();
    }
  }
}

function updateTimeOfDayUI() {
  timeOfDayEl.textContent = isNight ? 'Nighttime' : 'Daytime';
  if(isNight) {
    nightOverlay.style.display = 'block';
  } else {
    nightOverlay.style.display = 'none';
  }
}

function resetGame() {
  player.health = PLAYER_MAX_HEALTH;
  player.inventory = { wood:0, felt:0, door:0, torch:0, axe:0, chest:0, bed:0 };
  placingMode = false;
  placeItem = null;
  placeBtn.textContent = "Select Item to Place";
  isNight = false;
  dayNightTimer = 0;
  initWorld();
  renderWorld();
  updateUI();
  showMessage('Game reset!');
}

function gameLoop(timestamp) {
  if(!lastTimestamp) lastTimestamp = timestamp;
  const delta = timestamp - lastTimestamp;
  lastTimestamp = timestamp;

  updateDayNight(delta);

  updateUI();

  requestAnimationFrame(gameLoop);
}

initWorld();
renderWorld();
updateUI();
startMonsterDamage();
updateTimeOfDayUI();
requestAnimationFrame(gameLoop);

</script>

</body>
</html>
